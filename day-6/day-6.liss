(import "list" ["push" "reduce" "quicksort_mut" "SORT_ASC"])
(import "strings" ["split"])
(import "math" ["abs"])
(import "test_utils" ["benchmark"] as tu)

(let IS_DEBUG? false)

(let UP 0)
(let RIGHT 1)
(let DOWN 2)
(let LEFT 3)

(let MOVES (dict
    [UP    [0 -1]]
    [RIGHT [1  0]]
    [DOWN  [0  1]]
    [LEFT  [-1 0]]
))

(fn read_input_file [src]
    (let f (fopen src))
    (let data (fread_all f))
    (fclose f)
    data
)

; -> [ width height ]
(fn get_field_size [field]
    [(len (get field 0)) (len field)]
)

(fn locate_all [field glyph]
    (let size (get_field_size field))
    (fn _next [acc x y]
        (cond (>= y (get size 1))
            acc
            (cond (>= x (get size 0))
                (_next acc 0 (+ y 1))
                (
                    (let _glyph (get (get field y) x))
                    (let _acc (cond (= glyph _glyph)
                        (list:push acc [x y])
                        acc
                    ))
                    (_next _acc (+ x 1) y)
                )
            )
        )
    )

    (_next [] 0 0)
)

(fn prev_lt [arr n]
    (fn _next [a b]
        (cond (<= n (get arr a))
            -1
            (cond (> n (get arr b))
                b
                (cond (<= (- b a) 1)
                    (cond (<= n (get arr b))
                        a
                        -1
                    )
                    (
                        (let mid (/ (+ a b) 2))
                        (cond (> n (get arr mid))
                            (_next mid b)
                            (_next a mid)
                        )
                    )
                )
            )
        )
    )
    (cond (is_empty? arr)
        -1
        (_next 0 (- (len arr) 1))
    )
)

(fn next_gt [arr n]
    (fn _next [a b]
        (cond (>= n (get arr b))
            -1
            (cond (< n (get arr a))
                a
                (cond (<= (- b a) 1)
                    (cond (>= n (get arr a))
                        b
                        -1
                    )
                    (
                        (let mid (/ (+ a b) 2))
                        (cond (< n (get arr mid))
                            (_next a mid)
                            (_next mid b)
                        )
                    )
                )
            )
        )
    )
    (cond (is_empty? arr)
        -1
        (_next 0 (- (len arr) 1))
    )
)

(fn mk_obst_map [lines]
    (let size (get_field_size lines))
    (let obsts (locate_all lines "#"))
    (fn _next [acc ix]
        (cond (>= ix (len obsts))
            acc
            (
                (let x (get (get obsts ix) 0))
                (let y (get (get obsts ix) 1))
                (let vert (get acc 0))
                (let hor (get acc 1))
                (put vert x (list:push (get vert x) y))
                (put hor y (list:push (get hor y) x))
                (_next [vert hor] (+ ix 1))
            )
        )
    )
    ; [vert hor]
    (_next [(* [[]] (get size 0)) (* [[]] (get size 1))] 0)
)

(fn move_next [x0 y0 x1 y1]
    (let x2 (switch 
        [(is_null? x1) null ]
        [(= x0 x1) x0]
        [(< x0 x1) (- x1 1)]
        [(> x0 x1) (+ x1 1)]
    ))
    (let y2 (switch 
        [(is_null? y1) null ]
        [(= y0 y1) y0]
        [(< y0 y1) (- y1 1)]
        [(> y0 y1) (+ y1 1)]
    ))
    [x2 y2]
)

(fn goes_out? [move]
    (or
        (is_null? (get move 0))
        (is_null? (get move 1))
    )
)

(fn mk_key2 [x y]
    (+ x (* 1000 y))
)

(fn mk_key3 [x y dir]
    (+ x (* 1000 y) (* 1000000 dir))
)

(fn traverse_step [lines start sdir]
    (let obsts (locate_all lines "#"))
    (let size (get_field_size lines))
    (let obst_map (list:reduce obsts (fn [acc obst]
        (put acc (mk_key2 (get obst 0) (get obst 1)) null)
        acc
    ) (dict)))
    (fn _inbound [x y]
        (and (>= x 0) (>= y 0) (< x (get size 0)) (< y (get size 1)))
    )
    (fn _next [acc x y dir]
        (cond (_inbound x y)
            (
                (put acc (mk_key2 x y) null)
                (let mv (get MOVES dir))
                (let nx (+ x (get mv 0)))
                (let ny (+ y (get mv 1)))
                (cond (_inbound nx ny)
                    (cond (= (get (get lines ny) nx) "#")
                        (_next acc x y (% (+ dir 1) 4))
                        (_next acc nx ny dir)
                    )
                    (_next acc nx ny dir)
                )
            )
            acc
        )
    )
    (let visited (_next (dict) (get start 0) (get start 1) sdir))

    (fn _print_field [x y]
        (cond (< y (get size 1))
            (cond (>= x (get size 0))
                (
                    (print "\n")
                    (_print_field 0 (+ y 1))
                )
                (
                    (let k (mk_key2 x y))
                    (let glyph (switch
                        [(has? visited k) "X"]
                        [(has? obst_map k) "#"]
                        [* "."]
                    ))
                    (print glyph)
                    (_print_field (+ x 1) y)
                )
            )
        )
    )
    (_print_field 0 0)

    (len (keys visited))
)

; [dist, has_loop]
(fn traverse_jump [lines start sdir verts hors]
    (let size (get_field_size lines))
    (fn _next [acc x y dir]
        (let pos_key (mk_key3 x y dir))
        (cond IS_DEBUG? (println "visiting x=" x " y=" y " dir=" dir " pos key: " pos_key))
        (cond (has? acc pos_key)
            true
            (
                (put acc pos_key null)
                (switch dir
                    [UP (
                        (let _nm1 (move_next x y x (get (get verts x) (prev_lt (get verts x) y))))
                        (cond IS_DEBUG? (println "next move: " _nm1))
                        (cond (goes_out? _nm1)
                            false
                            (_next acc (get _nm1 0) (get _nm1 1) RIGHT)
                        )
                    )]
                    [DOWN (
                        (let _nm2 (move_next x y x (get (get verts x) (next_gt (get verts x) y))))
                        (cond IS_DEBUG? (println "next move: " _nm2))
                        (cond (goes_out? _nm2)
                            false
                            (_next acc (get _nm2 0) (get _nm2 1) LEFT)
                        )
                    )]
                    [RIGHT (
                        (let _nm3 (move_next x y (get (get hors y) (next_gt (get hors y) x)) y))
                        (cond IS_DEBUG? (println "next move: " _nm3))
                        (cond (goes_out? _nm3)
                            false
                            (_next acc (get _nm3 0) (get _nm3 1) DOWN)
                        )
                    )]
                    [LEFT (
                        (let _nm4 (move_next x y (get (get hors y) (prev_lt (get hors y) x)) y))
                        (cond IS_DEBUG? (println "next move: " _nm4))
                        (cond (goes_out? _nm4)
                            false
                            (_next acc (get _nm4 0) (get _nm4 1) UP)
                        )
                    )]
                )
            )
        )
    )
    ; 1 because we should collect the starting point
    (_next (dict) (get start 0) (get start 1) sdir)
)

(fn traverse_with_obst [lines start sdir verts hors obst_x obst_y]
    (let old_vert (list:copy (get verts obst_x)))
    (let old_hor (list:copy (get hors obst_y)))

    (cond IS_DEBUG?
        (
            (println "===============================")
            (println "visiting point x:" obst_x " y:" obst_y)
            (println "input verts=" verts " hors=" hors)
        )
    )

    (let new_vert (list:quicksort_fn_mut (list:push old_vert obst_y) list:SORT_ASC))
    (let new_hor  (list:quicksort_fn_mut (list:push old_hor  obst_x) list:SORT_ASC))

    (put verts obst_x new_vert)
    (put hors obst_y new_hor)

    (cond IS_DEBUG? (println "new verts=" verts " new hors=" hors))

    (let res (tu:benchmark "traverse_jump" (fn [] (traverse_jump lines start sdir verts hors))))

    (put verts obst_x old_vert)
    (put hors obst_y old_hor)
    (cond IS_DEBUG? (println "recovered verts=" verts " hors=" hors))

    (cond res 1 0)
)

((fn main []
    (let input (read_input_file "INPUT"))
    (let lines (strings:split input "\n"))
    (let size (get_field_size lines))
    (let obst_map (mk_obst_map lines))

    (let start (get (locate_all lines "^") 0))
    (println "start: " start)

    (let res1 (traverse_step lines start UP))
    (println "res1=" res1)

    (let verts (get obst_map 0))
    (let hors (get obst_map 1))

    (fn _next [acc x y]
        (cond (>= y (get size 1))
            acc
            (cond (>= x (get size 0))
                (_next acc 0 (+ y 1))
                (
                    (let _acc (cond (= (get (get lines y) x) ".")
                        (+ acc (tu:benchmark "traverse_with_obst" (fn [] (traverse_with_obst lines start UP verts hors x y))))
                        acc
                    ))
                    (_next _acc (+ x 1) y)
                )
            )
        )
    )
    (let res2 (_next 0 0 0))
    (println "res2=" res2)
))
